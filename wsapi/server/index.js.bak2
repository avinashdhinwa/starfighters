var WebSocket = require('ws')
var minimist = require('minimist')
var _ = require('lodash')

var url = 'wss://api.stockfighter.io/ob/api/ws/'
var argv = minimist(process.argv)
// console.log('argv : ', JSON.stringify(argv))
if (argv.url) { url = argv.url }
// if (!argv.account) { throw new Error('--account must be specified') }
// if (!argv.venue) { throw new Error('--venue must be specified')}
if (!argv.route) { throw new Error('--route must be specified')}
if (!argv.leveljs) { throw new Error('--leveljs required')}
var leveljs = require(argv.leveljs)
var WebSocketServer = require('ws').Server

var wsText = [url,
  leveljs.account,
  '/venues/',
  leveljs.venues[0],
  '/',
  argv.route].join('')
console.log('With : ', wsText)

function sockWrap (connectionString) {
  var active = null
  var buffer = []

  function init () {
    console.log('init..................................................\n\n\n\n')
    active = new WebSocket(wsText)
    active.on('message', function (data, flags) {
      // flags.binary will be set if a binary data is received.
      // flags.masked will be set if the data was masked.
      // console.log('> ', data)
      try {
        buffer.push(JSON.parse(data))
      } catch(e) {
        console.log('PARSE ERROR ', e)
      }
    })
    active.on('error', function (err) {
      console.log('ERROR >>>>> ', err)
    })
  }

  console.log('sockWrap')
  init()
  return {
    ping: active === null,
    get: function () { return _.cloneDeep(buffer) },
    reset: function () { console.log('reset!'); active = null; buffer = null; init(); },
    close: function () { active = null; buffer = null; }
  }
}

function throttle (fn, threshhold, scope) {
  threshhold || (threshhold = 250)
  var last,
    deferTimer
  return function () {
    var context = scope || this

    var now = +new Date,
      args = arguments
    if (last && now < last + threshhold) {
      // hold on to it
      clearTimeout(deferTimer)
      deferTimer = setTimeout(function () {
        last = now
        fn.apply(context, args)
      }, threshhold)
    } else {
      last = now
      fn.apply(context, args)
    }
  }
}

function Watcher () {
  var wss = null
  var sock = null

  return {
    wss: function () { return wss },
    start: function () { this.start() }.bind(this),
    stop: function () { this.stop() }.bind(this),
    restart: function () { this.restart() }.bind(this)
  }
}

Watcher.prototype.restart = function () {
  this.stop()
  this.start()
}

Watcher.prototype.stop = function () {
  if (this.wss) {
    wss.close()
  }
}
Watcher.prototype.start = function () {
  // Connect the the stockfigher ws api enpoint
  this.sock = sockWrap(wsText)

  this.wss = this.serverWrap()
}

Watcher.prototype.serverWrap = function () {
  var that = this
  console.log('serverWrap')

  this.wss = new WebSocketServer({ port: argv.port || 8080 })
  this.wss.on('connection', function connection (wsThing) {
    var intervalId = setInterval(function () {
      var data = that.sock.get()
      if (data.length > 0) {
        try {
          // console.log('.')
          if (argv.verbose) {
            console.log(JSON.stringify(data, null, 2))
          }
          wsThing.send(JSON.stringify(data))
        } catch(e) {
          console.log('ooops', e)
          console.log('Websocket died - trying to restart')
          clearInterval(intervalId)
          that.restart()
        }
      } else {
        throttle(function (e) { console.log('no data') }, 1000)
      }
    }, 100)
  })
  this.wss.on('close', function () {
    console.log('WSS  - client disconnected. Still active :  ', --active)
  })
}

var cluster = require('cluster')

var workers = 1 // process.env.WORKERS || require('os').cpus().length
if (cluster.isMaster) {
  console.log('start cluster with %s workers', workers)
  for (var i = 0; i < workers; ++i) {
    var worker = cluster.fork().process
    console.log('worker %s started.', worker.pid)
  }

  cluster.on('exit', function (worker) {
    console.log('worker %s died. restart...', worker.process.pid)
    cluster.fork()
  })

} else {
  console.log('wsServer on ', argv.port || 8080)
  var watch = new Watcher()
  watch.start()
}

process.on('uncaughtException', function (err) {
  console.error((new Date).toUTCString() + ' uncaughtException:', err.message)
  console.error(err.stack)
  process.exit(1)
})
